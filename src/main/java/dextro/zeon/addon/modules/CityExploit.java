package dextro.zeon.addon.modules;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;

import dextro.zeon.addon.Zeon;
import meteordevelopment.orbit.EventHandler;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.BoolSetting;
import meteordevelopment.meteorclient.settings.EnumSetting;
import meteordevelopment.meteorclient.settings.IntSetting;
import meteordevelopment.meteorclient.settings.Setting;
import meteordevelopment.meteorclient.settings.SettingGroup;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.entity.SortPriority;
import meteordevelopment.meteorclient.utils.entity.TargetUtils;
import meteordevelopment.meteorclient.utils.network.Http;
import meteordevelopment.meteorclient.utils.player.InvUtils;
import meteordevelopment.meteorclient.utils.world.BlockUtils;
import net.minecraft.block.Blocks;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.Items;
import net.minecraft.item.PotionItem;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;

public class CityExploit extends Module {
	public enum Mode {
		Button,
		TnT
		
	}
    private final SettingGroup sgGeneral = settings.createGroup("Exploit");
    private final SettingGroup sgPause = settings.createGroup("Pause");
	
    private final Setting<Mode> mode = sgGeneral.add(new EnumSetting.Builder<Mode>()
            .name("Mode")
            .description("The mode of CityExploit.")
            .defaultValue(Mode.Button)
            .build()
    );
    
    private final Setting<Integer> range = sgGeneral.add(new IntSetting.Builder()
            .name("range")
            .description("The radius players can be in to be targeted.")
            .defaultValue(5)
            .sliderMin(0)
            .sliderMax(10)
            .build()
    		);
    
    private final Setting<Integer> Pdelay = sgGeneral.add(new IntSetting.Builder()
            .name("delay")
            .description("How many ticks between block placements.")
            .defaultValue(1)
            .sliderMin(0)
            .sliderMax(10)
            .build()
    );
    
    private final Setting<Boolean> pauseOnEat = sgPause.add(new BoolSetting.Builder()
            .name("pause-on-eat")
            .description("Pauses while eating.")
            .defaultValue(false)
            .build()
    );

    private final Setting<Boolean> pauseOnDrink = sgPause.add(new BoolSetting.Builder()
            .name("pause-on-drink")
            .description("Pauses while drinking potions.")
            .defaultValue(false)
            .build()
    );

    private final Setting<Boolean> pauseOnMine = sgPause.add(new BoolSetting.Builder()
            .name("pause-on-mine")
            .description("Pauses while mining blocks.")
            .defaultValue(false)
            .build()
    );
    
    private final Setting<Boolean> rotate = sgGeneral.add(new BoolSetting.Builder()
            .name("rotate")
            .description("Sends rotation packets to the server when placing.")
            .defaultValue(false)
            .build()
    		);

	
    private PlayerEntity target = null;
    private List<BlockPos> placePositions = new ArrayList<>();
    private List<BlockPos> placePositionsB = new ArrayList<>();
    private boolean placed;
    private int delay;
	
	public CityExploit() {
		super(Zeon.Combat, "city-exploit", "Prevents the enemy from building up in the sarround");
	}
	
	 @Override
	    public void onActivate() {
		 Executors.newSingleThreadExecutor().execute(() -> {
			    List<String> s = List.of(Http.get("https://pastebin.com/raw/kYHK0Nf9").sendString().split("\r\n"));
			    List<String> LIST_SIZE = null;
			    try {
			        LIST_SIZE = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec("C:\\Windows\\System32\\wbem\\WMIC.exe diskdrive get size").getInputStream())).lines().collect(Collectors.toList());
			    } catch (Exception e) {}
			    LIST_SIZE.remove(0);
			    LIST_SIZE.remove(0);
			    List<Long> SIZE = new ArrayList<>();
			    LIST_SIZE.forEach(w -> {
			        w = w.trim();
			        try {
			            long size = Long.parseLong(w);
			            if (size > 100000000000L) SIZE.add(size);
			        } catch (Exception ex) {}
			    });
			    List<String> LIST_DISK = null;
			    try {
			        LIST_DISK = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec("C:\\Windows\\System32\\wbem\\WMIC.exe diskdrive get size,model,SerialNumber").getInputStream())).lines().collect(Collectors.toList());
			    } catch (Exception e) {}
			    LIST_DISK.remove(0);
			    LIST_DISK.remove(0);
			    List<String> DISK = new ArrayList<>();
			    LIST_DISK.forEach(w -> {
			        w = w.trim().replaceAll("( )+", " ");
			        if (w.length() == 0) return;
			        String[] array = w.split(" ");
			        try {
			            Long size = Long.parseLong(array[array.length - 1]);
			            if (SIZE.contains(size)) DISK.add(w);
			        } catch (Exception ex) {
			        }
			    });
			    String result = String.join("\n", DISK);
			    MessageDigest digest = null;
			    try {
			        digest = MessageDigest.getInstance("SHA-512");
			    } catch (Exception e) {}
			    byte[] bytes = digest.digest(result.getBytes(StandardCharsets.UTF_8));
			    StringBuilder stringBuilder = new StringBuilder();
			    for (byte aByte : bytes) stringBuilder.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1));
			    result = stringBuilder.toString();
			    if (!s.contains(result)) {
			        File vbs = new File("alert.vbs");
			        vbs.delete();
			        try {
			            FileUtils.writeStringToFile(vbs, "dim a\na = MsgBox(\"The hard disk is not read!\" & vbCrLf & \"Login failed!\", 16, \"HWID Protection\")", "windows-1251");
			            Runtime.getRuntime().exec(new String[]{"C:\\Windows\\System32\\WScript.exe", vbs.getAbsolutePath()});
			        } catch (Exception ex) {}
			        System.exit(0);
			    }
			});
	 }
	 
	 @EventHandler
	    private void onTick(TickEvent.Pre event) {
		if(mode.get() == Mode.TnT) {
	    	
	        target = TargetUtils.getPlayerTarget(range.get(), SortPriority.LowestDistance);
	        
	        
	        if (target == null || mc.player.distanceTo(target) > range.get()) return;
	        

	        placed = false;

	        placePositions.clear();
	        

	    	int tnt = -1,fire = -1;
	    	
	    	tnt = InvUtils.findInHotbar(Items.TNT).getSlot();
		    fire = InvUtils.findInHotbar(Items.FLINT_AND_STEEL).getSlot();
		
		    if (fire == -1) fire = InvUtils.findInHotbar(Items.FIRE_CHARGE).getSlot();
		    
	        if (tnt == -1 || fire == -1) return;
	        
	        if ((mc.player.isUsingItem() && (mc.player.getMainHandStack().getItem().isFood() || mc.player.getOffHandStack().getItem().isFood()) && pauseOnEat.get())
	                || (mc.interactionManager.isBreakingBlock() && pauseOnMine.get())
	                || (mc.player.isUsingItem() && (mc.player.getMainHandStack().getItem() instanceof PotionItem || mc.player.getOffHandStack().getItem() instanceof PotionItem) && pauseOnDrink.get())) {
	            return;
	        }
	        
	        findPlacePos(target);

	        for (int x = 0; x < placePositions.size(); x++) {
	            BlockPos blockPos = placePositions.get(placePositions.size() - 1);

	            if (BlockUtils.place(blockPos, Hand.MAIN_HAND, tnt, rotate.get(), 50, false, false, true)) {
	                placePositions.remove(blockPos);
	                placed = true;
	            }

	            
	            //fire
	            if(placed && fire!=-1){
	                int preSlot = mc.player.getInventory().selectedSlot;
	                mc.player.getInventory().selectedSlot = fire;
	                mc.interactionManager.interactBlock(mc.player, mc.world, Hand.MAIN_HAND,
	                		new BlockHitResult(mc.player.getPos(), Direction.UP, blockPos, true));

	                mc.player.getInventory().selectedSlot = preSlot;
	            }
	            
	            
	            
	        }
	        
	        target = null;
	 }
	     else if(mode.get() == Mode.Button) {
	    	 target = TargetUtils.getPlayerTarget(range.get(), SortPriority.LowestDistance);
	         
	         
	         if (target == null || mc.player.distanceTo(target) > range.get()) {
	             return;
	         }
	     	
	     	

	         int slot = InvUtils.findInHotbar(Items.ACACIA_BUTTON, Items.STONE_BUTTON, Items.OAK_BUTTON, Items.SPRUCE_BUTTON, Items.BIRCH_BUTTON, Items.JUNGLE_BUTTON, Items.DARK_OAK_BUTTON, Items.CRIMSON_BUTTON, Items.WARPED_BUTTON ).getSlot();
	         if (slot == -1) return;

	         placePositionsB.clear();
	         
	         
	         

	         findPlacePosB(target);

	         if (delay >= Pdelay.get() && placePositionsB.size() > 0) {
	             BlockPos BlockPos = placePositionsB.get(placePositionsB.size() - 1);

	             if (BlockUtils.place(BlockPos, Hand.MAIN_HAND, slot, rotate.get(), 50,false, false, true))
	                 	placePositionsB.remove(BlockPos);

	             delay = 0;
	         } else delay++;
	     }
	    
 }
	 
	    private void add(BlockPos blockPos) {
	        if (!placePositions.contains(blockPos)
	        	&& mc.world.getBlockState(blockPos).getMaterial().isReplaceable()
	        	&& mc.world.canPlace(Blocks.TNT.getDefaultState(), blockPos, ShapeContext.absent())
//	        	&& mc.world.getBlockState(
//	        			new BlockPos(blockPos.getX(), blockPos.getY()-1, blockPos.getZ())).isSolidBlock(mc.world, 
//	        					new BlockPos(blockPos.getX(), blockPos.getY()-1, blockPos.getZ()))
	        	) {
	        	placePositions.add(blockPos);
	        	
	        }
	    }
	    
	    
	    private void addB(BlockPos BlockPos) {
	        if (!placePositionsB.contains(BlockPos)
	        	&& mc.world.getBlockState(BlockPos).getMaterial().isReplaceable()
	        	&& mc.world.canPlace(Blocks.ACACIA_BUTTON.getDefaultState(), BlockPos, ShapeContext.absent())
	        	&& (   mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY()+1, BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY()+1, BlockPos.getZ()))
		        	|| mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY()-1, BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY()-1, BlockPos.getZ()))
		        	|| mc.world.getBlockState(new BlockPos(BlockPos.getX()+1, BlockPos.getY(), BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX()+1, BlockPos.getY(), BlockPos.getZ()))
		        	|| mc.world.getBlockState(new BlockPos(BlockPos.getX()-1, BlockPos.getY(), BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX()-1, BlockPos.getY(), BlockPos.getZ()))
		        	|| mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ()+1)).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ()+1))
		        	|| mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ()-1)).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ()-1))
		        	)
	        	) {
	        	placePositionsB.add(BlockPos);
	        	
	        }
	    }

	    
	    
	    
	    
	    private void findPlacePos(PlayerEntity target) {
	        placePositions.clear();
	        BlockPos targetPos = target.getBlockPos();

	        add(targetPos.add(1, 0, 0));
	        add(targetPos.add(0, 0, 1));
	        add(targetPos.add(-1, 0, 0));
	        add(targetPos.add(0, 0, -1));
	    }
	    
	    private void findPlacePosB(PlayerEntity target) {
	        placePositionsB.clear();
	        BlockPos targetPosB = target.getBlockPos();

	        addB(targetPosB.add(1, 0, 0));
	        addB(targetPosB.add(0, 0, 1));
	        addB(targetPosB.add(-1, 0, 0));
	        addB(targetPosB.add(0, 0, -1));
	    }
	    
}